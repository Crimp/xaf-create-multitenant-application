@using System.Text.Json
@using System.Text.RegularExpressions
@using DevExpress.Map.Native
@using DevExpress.Persistent.Base
@using OutlookInspired.Module.BusinessObjects
@using OutlookInspired.Module.Features.Maps
<DxMap Provider="MapProvider.Bing" Width="100%" Height="600px" Zoom="16">
    <DxMapCenter GeoPosition="@GetLocation(Center)" />
    <DxMapApiKeys Bing="@MapsViewController.BindKey"></DxMapApiKeys>
    <DxMapMarkers>
        @foreach (var entity in Markers){
            <DxMapMarker MarkerId="@entity.Key">
                <DxMapMarkerLocation GeoPosition="@GetLocation(entity.Value)"/>
                <DxMapMarkerTooltip Text="@entity.Value.Title" Visible="@(!string.IsNullOrEmpty(entity.Value.Title))"/>
            </DxMapMarker>
        }
    </DxMapMarkers>
    <DxMapRoutes>
        <DxMapRoute Mode="@MapRouteMode" Weight="9">
            <DxMapRouteLocations>
                @foreach (var entity in Markers){
                    <DxMapRouteLocation Latitude="@entity.Value.Latitude" Longitude="@entity.Value.Longitude"></DxMapRouteLocation>
                }
            </DxMapRouteLocations>
        </DxMapRoute>
        
    </DxMapRoutes>
</DxMap>

@code {
    [Parameter][EditorRequired]
    public EventCallback<RouteCalculatedArgs> RouteCalculated{ get; set; }
    [Parameter][EditorRequired]
    public Dictionary<string, IMapsMarker> Markers{ get; set; }
    [Parameter][EditorRequired]
    public IMapsMarker Center{ get; set; }
    [Parameter][EditorRequired]
    public MapRouteMode MapRouteMode{ get; set; }
    [Parameter][EditorRequired]
    public bool CalculateRoute{ get; set; }

    private string GetLocation(IMapsMarker mapsMarker) => $"{mapsMarker.Latitude}, {mapsMarker.Longitude}";

    protected override async Task OnAfterRenderAsync(bool firstRender){
        if (!CalculateRoute)return;
        var e = await ManeuverInstructions(Markers.Values.First(),Markers.Values.Last(),MapRouteMode.ToString(),MapsViewController.BindKey);
        await RouteCalculated.InvokeAsync(e);
    }

    
    static async Task<RouteCalculatedArgs> ManeuverInstructions(IMapsMarker locationA, IMapsMarker locationB, string travelMode, string apiKey){
        var url = $"https://dev.virtualearth.net/REST/V1/Routes/{travelMode}?wp.0={locationA.Latitude},{locationA.Longitude}&wp.1={locationB.Latitude},{locationB.Longitude}&key={apiKey}";
        using var httpClient = new HttpClient();
        var httpResponseMessage = await httpClient.GetAsync(url);
        if (httpResponseMessage.IsSuccessStatusCode){
            var jsonString = await httpResponseMessage.Content.ReadAsStringAsync();
            using var jsonDoc = JsonDocument.Parse(jsonString);
            var result = jsonDoc.RootElement.GetProperty("resourceSets").EnumerateArray().First().GetProperty("resources").EnumerateArray().First();
            var routeLegs = result.GetProperty("routeLegs").EnumerateArray().SelectMany(leg => leg.GetProperty("itineraryItems").EnumerateArray());
            var routePoints = routeLegs.Select(RoutePoint).ToArray();
            var travelDistance = result.GetProperty("travelDistance").GetDouble();
            var travelDuration = result.GetProperty("travelDuration").GetDouble();
            return new RouteCalculatedArgs(routePoints, travelDistance, TimeSpan.FromMinutes(travelDuration), Enum.Parse<TravelMode>(travelMode, true));
        }

        return new RouteCalculatedArgs(Array.Empty<RoutePoint>(), 0, TimeSpan.Zero, Enum.Parse<TravelMode>(travelMode, true));
    }
    private static readonly Regex RemoveTagRegex = new(@"<[^>]*>", RegexOptions.Compiled);
    private static RoutePoint RoutePoint( JsonElement item){
        var point = new RoutePoint{
            ManeuverInstruction = RemoveTagRegex.Replace(item.GetProperty("instruction").GetProperty("text").GetString()!, string.Empty),
            Maneuver = Enum.Parse<BingManeuverType>(item.GetProperty("details").EnumerateArray().First().GetProperty("maneuverType").GetString()!)
        };
        var distance = item.GetProperty("travelDistance").GetDouble();
        point.Distance = distance > 0.9 ? $"{Math.Ceiling(distance):0} mi" : $"{Math.Ceiling(distance * 52.8) * 100:0} ft";
        return point;
    }


}